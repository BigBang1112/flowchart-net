@implements IDraggable

<div class="symbol symbol-decision" style="position: absolute; left: @(Data.X)px; top: @(Data.Y)px; width: @(Data.Width)px; height: @(Data.Height)px">
    <div class="shape symbol-hoverable" style="width: calc(@(Data.Height)px * sin(45deg) + 2px); height: calc(@(Data.Height)px * sin(45deg) + 2px); transform: scaleX(@Data.ScaleX) rotate(45deg); cursor: @(IsDragging ? "grabbing" : "grab");"
    @onmousedown="MouseDownAsync"
    @onmousedown:preventDefault="true"></div>
    <span>Decision</span>
    <div @ref="pointTop" class="connect connect-top connect-top-decision" @onclick="() => OnPointClick.InvokeAsync(pointTop)"></div>
    <div @ref="pointBottom" class="connect connect-bottom connect-bottom-decision" @onclick="() => OnPointClick.InvokeAsync(pointBottom)"></div>
    <div @ref="pointLeft" class="connect connect-left-decision" @onclick="() => OnPointClick.InvokeAsync(pointLeft)"></div>
    <div @ref="pointRight" class="connect connect-right-decision" @onclick="() => OnPointClick.InvokeAsync(pointRight)"></div>
</div>

@code {
    private ElementReference pointTop;
    private ElementReference pointBottom;
    private ElementReference pointLeft;
    private ElementReference pointRight;

    public bool IsDragging { get; set; }

    [Parameter, EditorRequired]
    public required DecisionSymbolData Data { get; set; }

    double IDraggable.X { get => Data.X; set => Data.X = value; }
    double IDraggable.Y { get => Data.Y; set => Data.Y = value; }

    [Parameter]
    public EventCallback<SymbolDragEventArgs> OnMouseDown { get; set; }

    [Parameter]
    public EventCallback<ElementReference> OnPointClick { get; set; }

    private async Task MouseDownAsync(MouseEventArgs e)
    {
        IsDragging = true;
        await OnMouseDown.InvokeAsync(new SymbolDragEventArgs(this, e));
    }
}
