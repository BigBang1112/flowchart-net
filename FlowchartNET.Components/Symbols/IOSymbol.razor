@using FlowchartNET.Components.Events
@implements IDraggable

<div class="symbol symbol-io" style="position: absolute; left: @(Data.X)px; top: @(Data.Y)px; width: @(Data.Width)px;">
    <div @ref="shape" class="shape symbol-hoverable @(Selected ? "selected" : "")"
    style="width: calc(100% - (@(IOSymbolData.DefaultHeight)px * tan(20deg))); height: @(IOSymbolData.DefaultHeight)px; cursor: @(IsDragging ? "grabbing" : "grab");"
         @onmousedown="MouseDownAsync"
         @onmousedown:preventDefault="true"
         @onmousedown:stopPropagation="true"
         @ontouchstart="TouchStartAsync"
         @ontouchstart:preventDefault="true"></div>
    <span>Input / Output</span>
    <div class="connect connect-top connect-top-io"
         @onclick="() => OnPointClickAsync(socketTop)"
         @onclick:stopPropagation="true"
         @onmousedown:preventDefault="true"></div>
    <div class="connect connect-bottom connect-bottom-io"
         @onclick="() => OnPointClickAsync(socketBottom, conn => { Data.NextSymbols.Add(conn.DestSymbolId); })"
         @onclick:stopPropagation="true"
         @onmousedown:preventDefault="true"></div>
</div>

@code {
    private ElementReference shape;
    private IJSObjectReference? nextSymbolLine;

    private static string socketTop = "top";
    private static string socketBottom = "bottom";

    public bool IsDragging { get; set; }

    [Parameter, EditorRequired]
    public required IOSymbolData Data { get; set; }

    Guid IDraggable.Id => Data.Id;
    double IDraggable.X { get => Data.X; set => Data.X = value; }
    double IDraggable.Y { get => Data.Y; set => Data.Y = value; }

    [Parameter]
    public EventCallback<SymbolDragEventArgs> OnMouseDown { get; set; }

    [Parameter]
    public EventCallback<PointClickEventArgs> OnPointClick { get; set; }

    [Parameter]
    public bool Selected { get; set; }

    private async Task MouseDownAsync(MouseEventArgs e)
    {
        IsDragging = true;
        await OnMouseDown.InvokeAsync(new SymbolDragEventArgs(this, e.ClientX, e.ClientY));
    }

    private async Task TouchStartAsync(TouchEventArgs e)
    {
        if (e.Touches.Length == 0)
        {
            return;
        }

        IsDragging = true;
        await OnMouseDown.InvokeAsync(new SymbolDragEventArgs(this, e.Touches[0].ClientX, e.Touches[0].ClientY));
    }

    private async Task OnPointClickAsync(string socket, Action<LineConnection>? connector = null)
    {
        await OnPointClick.InvokeAsync(new PointClickEventArgs(this, shape, socket, connector));
    }
}
