@implements IAsyncDisposable
@inject IJSRuntime JS

<main @ondragover="OnDragOver" @ondragover:preventDefault="true">
    @foreach (var symbol in symbols)
    {
        <DynamicComponent Type="symbol.ComponentType" Parameters="GetSymbolComponentParameters(symbol)" />
    }
</main>

@code {
    private IJSObjectReference? module;

    private DotNetObjectReference<Workspace>? objRef;

    private List<SymbolData> symbols = [];

    protected override void OnInitialized() =>
        objRef = DotNetObjectReference.Create(this);

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>("import",
                "./_content/FlowchartNET.Components/Workspace.razor.js");
            await module.InvokeVoidAsync("addHandlers", objRef);
        }
    }

    private void OnDragOver(DragEventArgs e)
    {
        // prevent default behavior
    }

    [JSInvokable]
    public void AddSymbol(string symbolId, double x, double y)
    {
        switch (symbolId)
        {
            case "symbol-terminal":
                symbols.Add(new StartSymbolData { X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2), Y = y });
                symbols.Add(new EndSymbolData { X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2), Y = y + 100 });
                break;
            case "symbol-process":
                symbols.Add(new ProcessSymbolData { X = Math.Max(0, x - ProcessSymbolData.DefaultWidth / 2), Y = y });
                break;
            case "symbol-io":
                symbols.Add(new IOSymbolData { X = Math.Max(0, x - IOSymbolData.DefaultWidth / 2), Y = y });
                break;
            case "symbol-decision":
                symbols.Add(new DecisionSymbolData { X = Math.Max(0, x - DecisionSymbolData.DefaultWidth / 2), Y = y });
                break;
        }
        StateHasChanged();
    }

    private Dictionary<string, object> GetSymbolComponentParameters(SymbolData data) =>
        new Dictionary<string, object>
        {
            { "Data", data }
        };

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}
