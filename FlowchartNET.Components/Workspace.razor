@using FlowchartNET.Components.Events
@implements IAsyncDisposable

@inject ModuleHelper ModuleHelper
@inject AppState AppState
@inject EventBroadcastService EventBroadcast

<main @ondragover="OnDragOver"
@onclick="OnClickAsync"
@ondragover:preventDefault="true" 
@onmousemove="OnMouseMoveAsync"
@onmouseup="OnMouseUpAsync"
@ontouchmove="OnTouchMoveAsync"
@ontouchmove:preventDefault="true"
@ontouchcancel="OnMouseUpAsync"
@onscroll="OnScrollAsync">
    @foreach (var symbol in AppState.Symbols)
    {
        <DynamicComponent Type="symbol.ComponentType" Parameters="GetSymbolComponentParameters(symbol)" />
    }
</main>

@code {
    private IJSObjectReference? module;

    private DotNetObjectReference<Workspace>? objRef;

    private IDraggable? currentlyDraggedSymbol;
    private double currentlyDraggedSymbolOffsetX;
    private double currentlyDraggedSymbolOffsetY;

    private PointClickEventArgs? currentConnectorEvent;
    private List<IJSObjectReference> lines = [];

    protected override void OnInitialized() =>
        objRef = DotNetObjectReference.Create(this);

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await ModuleHelper.ImportAsync(nameof(Workspace), nameof(WorkspaceModule));
            await module.InvokeVoidAsync("addHandlers", objRef);
        }
    }

    private void OnDragOver(DragEventArgs e)
    {
        // prevent default behavior
    }

    private async Task OnClickAsync(MouseEventArgs e)
    {
        if (module is null)
        {
            return;
        }

        if (AppState.SelectedSymbolId is not null)
        {
            var mouseX = WorkspaceModule.GetMouseX(e.ClientX);
            var mouseY = WorkspaceModule.GetMouseY(e.ClientY);
            AddSymbol(AppState.SelectedSymbolId, mouseX, mouseY);
        }

        if (currentConnectorEvent is not null)
        {
            await module.InvokeVoidAsync("removeCurrentLine");
            currentConnectorEvent = null;
        }
    }

    [JSInvokable]
    public void AddSymbol(string symbolId, double x, double y)
    {
        switch (symbolId)
        {
            case "symbol-terminal":
                AppState.Symbols.Add(new StartSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2
                    });
                AppState.Symbols.Add(new EndSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2 + 100
                    });
                break;
            case "symbol-process":
                AppState.Symbols.Add(new ProcessSymbolData
                    {
                        X = Math.Max(0, x - ProcessSymbolData.DefaultWidth / 2),
                        Y = y - ProcessSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-io":
                AppState.Symbols.Add(new IOSymbolData
                    {
                        X = Math.Max(0, x - IOSymbolData.DefaultWidth / 2),
                        Y = y - IOSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-decision":
                AppState.Symbols.Add(new DecisionSymbolData
                    {
                        X = Math.Max(0, x - DecisionSymbolData.DefaultHeight * DecisionSymbolData.DefaultScaleX / 2),
                        Y = y - DecisionSymbolData.DefaultHeight / 2
                    });
                break;
        }
        AppState.SelectedSymbolId = null;
        EventBroadcast.UpdateMenu();
        StateHasChanged();
    }

    private Dictionary<string, object> GetSymbolComponentParameters(SymbolData data) =>
        new Dictionary<string, object>
        {
            { "Data", data },
            { "OnMouseDown", EventCallback.Factory.Create<SymbolDragEventArgs>(this, OnSymbolMouseDown) },
            { "OnPointClick", EventCallback.Factory.Create<PointClickEventArgs>(this, OnSymbolPointClickAsync) }
        };

    private void OnSymbolMouseDown(SymbolDragEventArgs e)
    {
        currentlyDraggedSymbolOffsetX = e.Draggable.X - WorkspaceModule.GetMouseX(e.ClientX);
        currentlyDraggedSymbolOffsetY = e.Draggable.Y - WorkspaceModule.GetMouseY(e.ClientY);
        currentlyDraggedSymbol = e.Draggable;
    }

    private async Task OnMouseMoveAsync(MouseEventArgs e)
    {
        await SymbolMoveAsync(e.ClientX, e.ClientY);
    }

    private async Task OnTouchMoveAsync(TouchEventArgs e)
    {
        if (e.Touches.Length == 0)
        {
            return;
        }

        await SymbolMoveAsync(e.Touches[0].ClientX, e.Touches[0].ClientY);
    }

    private async Task SymbolMoveAsync(double clientX, double clientY)
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.X = Math.Max(0, WorkspaceModule.GetMouseX(clientX) + currentlyDraggedSymbolOffsetX);
            currentlyDraggedSymbol.Y = Math.Max(0, WorkspaceModule.GetMouseY(clientY) + currentlyDraggedSymbolOffsetY);

            await UpdateLinePositionsAsync();
        }
    }

    private async Task OnMouseUpAsync()
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.IsDragging = false;
            currentlyDraggedSymbol = null;

            await UpdateLinePositionsAsync();
        }
    }

    private async Task OnScrollAsync()
    {
        await UpdateLinePositionsAsync();
    }

    private async Task OnSymbolPointClickAsync(PointClickEventArgs e)
    {
        if (module is null)
        {
            return;
        }

        if (currentConnectorEvent is null)
        {
            if (e.Socket == "top")
            {
                return;
            }

            currentConnectorEvent = e;
            await module.InvokeVoidAsync("startLine", e.Element, e.Socket);
            return;
        }

        if (currentConnectorEvent.Symbol.Id == e.Symbol.Id)
        {
            currentConnectorEvent = null;
            return;
        }

        var completedLine = await module.InvokeAsync<IJSObjectReference>("endLine", e.Element, e.Socket);

        currentConnectorEvent.Connector?.Invoke(e.Symbol.Id);

        lines.Add(completedLine);

        currentConnectorEvent = null;
    }

    private async ValueTask UpdateLinePositionsAsync()
    {
        if (module is null)
        {
            return;
        }

        foreach (var line in lines)
        {
            await line.InvokeVoidAsync("position");
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}
