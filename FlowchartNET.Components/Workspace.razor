@using System.Runtime.InteropServices.JavaScript
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject AppState AppState
@inject EventBroadcastService EventBroadcast

<main @ondragover="OnDragOver" @onclick="OnClickAsync" @ondragover:preventDefault="true">
    @foreach (var symbol in AppState.Symbols)
    {
        <DynamicComponent Type="symbol.ComponentType" Parameters="GetSymbolComponentParameters(symbol)" />
    }
</main>

@code {
    private IJSObjectReference? module;

    private DotNetObjectReference<Workspace>? objRef;

    [Parameter]
    public EventCallback OnSymbolAdd { get; set; }

    protected override void OnInitialized() =>
        objRef = DotNetObjectReference.Create(this);

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>("import",
                "./_content/FlowchartNET.Components/Workspace.razor.js");
            await module.InvokeVoidAsync("addHandlers", objRef);
        }
    }

    private void OnDragOver(DragEventArgs e)
    {
        // prevent default behavior
    }

    private async Task OnClickAsync(MouseEventArgs e)
    {
        if (AppState.SelectedSymbolId is not null && module is not null)
        {
            var mouseX = await module.InvokeAsync<double>("getMouseX", e);
            var mouseY = await module.InvokeAsync<double>("getMouseY", e);
            AddSymbol(AppState.SelectedSymbolId, mouseX, mouseY);
        }
    }

    [JSInvokable]
    public void AddSymbol(string symbolId, double x, double y)
    {
        switch (symbolId)
        {
            case "symbol-terminal":
                AppState.Symbols.Add(new StartSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2
                    });
                AppState.Symbols.Add(new EndSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2 + 100
                    });
                break;
            case "symbol-process":
                AppState.Symbols.Add(new ProcessSymbolData
                    {
                        X = Math.Max(0, x - ProcessSymbolData.DefaultWidth / 2),
                        Y = y - ProcessSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-io":
                AppState.Symbols.Add(new IOSymbolData
                    {
                        X = Math.Max(0, x - IOSymbolData.DefaultWidth / 2),
                        Y = y - IOSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-decision":
                AppState.Symbols.Add(new DecisionSymbolData
                    {
                        X = Math.Max(0, x - DecisionSymbolData.DefaultHeight * DecisionSymbolData.DefaultScaleX / 2),
                        Y = y - DecisionSymbolData.DefaultHeight / 2
                    });
                break;
        }
        AppState.SelectedSymbolId = null;
        EventBroadcast.UpdateMenu();
        StateHasChanged();
    }

    private Dictionary<string, object> GetSymbolComponentParameters(SymbolData data) =>
        new Dictionary<string, object>
        {
            { "Data", data }
        };

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}
