@implements IAsyncDisposable

@inject ModuleHelper ModuleHelper
@inject AppState AppState
@inject EventBroadcastService EventBroadcast

<main @ondragover="OnDragOver" @onclick="OnClick" @ondragover:preventDefault="true" @onmousemove="OnMouseMove" @onmouseup="OnMouseUp">
    @foreach (var symbol in AppState.Symbols)
    {
        <DynamicComponent Type="symbol.ComponentType" Parameters="GetSymbolComponentParameters(symbol)" />
    }
</main>

@code {
    private IJSObjectReference? module;

    private DotNetObjectReference<Workspace>? objRef;

    private IDraggable? currentlyDraggedSymbol;
    private double currentlyDraggedSymbolOffsetX;
    private double currentlyDraggedSymbolOffsetY;

    private ElementReference? connectorElement;

    protected override void OnInitialized() =>
        objRef = DotNetObjectReference.Create(this);

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await ModuleHelper.ImportAsync(nameof(Workspace), nameof(WorkspaceModule));
            await module.InvokeVoidAsync("addHandlers", objRef);
        }
    }

    private void OnDragOver(DragEventArgs e)
    {
        // prevent default behavior
    }

    private void OnClick(MouseEventArgs e)
    {
        if (AppState.SelectedSymbolId is not null && module is not null)
        {
            var mouseX = WorkspaceModule.GetMouseX(e.ClientX);
            var mouseY = WorkspaceModule.GetMouseY(e.ClientY);
            AddSymbol(AppState.SelectedSymbolId, mouseX, mouseY);
        }
    }

    [JSInvokable]
    public void AddSymbol(string symbolId, double x, double y)
    {
        switch (symbolId)
        {
            case "symbol-terminal":
                AppState.Symbols.Add(new StartSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2
                    });
                AppState.Symbols.Add(new EndSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2 + 100
                    });
                break;
            case "symbol-process":
                AppState.Symbols.Add(new ProcessSymbolData
                    {
                        X = Math.Max(0, x - ProcessSymbolData.DefaultWidth / 2),
                        Y = y - ProcessSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-io":
                AppState.Symbols.Add(new IOSymbolData
                    {
                        X = Math.Max(0, x - IOSymbolData.DefaultWidth / 2),
                        Y = y - IOSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-decision":
                AppState.Symbols.Add(new DecisionSymbolData
                    {
                        X = Math.Max(0, x - DecisionSymbolData.DefaultHeight * DecisionSymbolData.DefaultScaleX / 2),
                        Y = y - DecisionSymbolData.DefaultHeight / 2
                    });
                break;
        }
        AppState.SelectedSymbolId = null;
        EventBroadcast.UpdateMenu();
        StateHasChanged();
    }

    private Dictionary<string, object> GetSymbolComponentParameters(SymbolData data) =>
        new Dictionary<string, object>
        {
            { "Data", data },
            { "OnMouseDown", EventCallback.Factory.Create<SymbolDragEventArgs>(this, OnSymbolMouseDown) },
            { "OnPointClick", EventCallback.Factory.Create<ElementReference>(this, OnSymbolPointClickAsync) }
        };

    private void OnSymbolMouseDown(SymbolDragEventArgs e)
    {
        currentlyDraggedSymbolOffsetX = e.Draggable.X - WorkspaceModule.GetMouseX(e.Mouse.ClientX);
        currentlyDraggedSymbolOffsetY = e.Draggable.Y - WorkspaceModule.GetMouseY(e.Mouse.ClientY);
        currentlyDraggedSymbol = e.Draggable;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.X = Math.Max(0, WorkspaceModule.GetMouseX(e.ClientX) + currentlyDraggedSymbolOffsetX);
            currentlyDraggedSymbol.Y = Math.Max(0, WorkspaceModule.GetMouseY(e.ClientY) + currentlyDraggedSymbolOffsetY);
        }
    }

    private void OnMouseUp()
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.IsDragging = false;
            currentlyDraggedSymbol = null;
        }
    }

    private async Task OnSymbolPointClickAsync(ElementReference element)
    {
        if (connectorElement is null)
        {
            connectorElement = element;
            return;
        }

        if (module is null)
        {
            return;
        }

        await module.InvokeVoidAsync("connect", connectorElement, element);

        connectorElement = null;
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}
