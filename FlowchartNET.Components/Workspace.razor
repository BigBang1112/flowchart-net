@using FlowchartNET.Components.Events
@implements IAsyncDisposable

@inject ModuleHelper ModuleHelper
@inject AppState AppState
@inject EventBroadcastService EventBroadcast

<main @ondragover="OnDragOver"
@onclick="OnClickAsync"
@ondragover:preventDefault="true" 
@onmousemove="OnMouseMoveAsync"
@onmousedown="OnMouseDownAsync"
@onmouseup="OnMouseUpAsync"
@ontouchmove="OnTouchMoveAsync"
@ontouchmove:preventDefault="true"
@ontouchcancel="OnMouseUpAsync"
@onscroll="OnScrollAsync">

    @foreach (var symbol in AppState.Symbols)
    {
        <DynamicComponent Type="symbol.ComponentType" Parameters="GetSymbolComponentParameters(symbol)" />
    }

</main>
<aside class="@(AppState.IsOptionsOpen ? "open" : "")">
    <div class="opener" @onclick="() => AppState.IsOptionsOpen = !AppState.IsOptionsOpen">
        <img class="@(AppState.IsOptionsOpen ? "open" : "")" src="_content/FlowchartNET.Components/img/icons/chevron_left.svg" width="48" height="48" />
        <span>Symbol</span>
    </div>
</aside>
@code {
    private IJSObjectReference? module;

    private DotNetObjectReference<Workspace>? objRef;

    private IDraggable? currentlyDraggedSymbol;
    private double currentlyDraggedSymbolOffsetX;
    private double currentlyDraggedSymbolOffsetY;

    private PointClickEventArgs? currentConnectorEvent;
    private Dictionary<(Guid FromSymbolId, Guid ToSymbolId), IJSObjectReference> lines = [];

    protected override void OnInitialized() =>
        objRef = DotNetObjectReference.Create(this);

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await ModuleHelper.ImportAsync(nameof(Workspace), nameof(WorkspaceModule));
            await module.InvokeVoidAsync("addHandlers", objRef);
        }
    }

    private void OnDragOver(DragEventArgs e)
    {
        // prevent default behavior
    }

    private async Task OnClickAsync(MouseEventArgs e)
    {
        if (module is null)
        {
            return;
        }

        if (AppState.MenuSelectedSymbolId is not null)
        {
            var mouseX = WorkspaceModule.GetMouseX(e.ClientX);
            var mouseY = WorkspaceModule.GetMouseY(e.ClientY);

            await AddSymbolAsync(AppState.MenuSelectedSymbolId, mouseX, mouseY);
        }

        if (currentConnectorEvent is not null)
        {
            await module.InvokeVoidAsync("removeCurrentLine");
            currentConnectorEvent = null;
        }
    }

    [JSInvokable]
    public async Task AddSymbolAsync(string symbolId, double x, double y)
    {
        switch (symbolId)
        {
            case "symbol-terminal":
                AppState.Symbols.Add(new StartSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2
                    });
                AppState.Symbols.Add(new EndSymbolData
                    {
                        X = Math.Max(0, x - EndSymbolData.DefaultWidth / 2),
                        Y = y - EndSymbolData.DefaultHeight / 2 + 100
                    });
                break;
            case "symbol-process":
                AppState.Symbols.Add(new ProcessSymbolData
                    {
                        X = Math.Max(0, x - ProcessSymbolData.DefaultWidth / 2),
                        Y = y - ProcessSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-io":
                AppState.Symbols.Add(new IOSymbolData
                    {
                        X = Math.Max(0, x - IOSymbolData.DefaultWidth / 2),
                        Y = y - IOSymbolData.DefaultHeight / 2
                    });
                break;
            case "symbol-decision":
                AppState.Symbols.Add(new DecisionSymbolData
                    {
                        X = Math.Max(0, x - DecisionSymbolData.DefaultHeight * DecisionSymbolData.DefaultScaleX / 2),
                        Y = y - DecisionSymbolData.DefaultHeight / 2
                    });
                break;
        }

        AppState.MenuSelectedSymbolId = null;
        EventBroadcast.UpdateMenu();
        StateHasChanged();

        await AppState.PersistAsync();
    }

    private Dictionary<string, object> GetSymbolComponentParameters(SymbolData data) =>
        new Dictionary<string, object>
        {
            { "Data", data },
            { "OnMouseDown", EventCallback.Factory.Create<SymbolDragEventArgs>(this, OnSymbolMouseDownAsync) },
            { "OnPointClick", EventCallback.Factory.Create<PointClickEventArgs>(this, OnSymbolPointClickAsync) },
            { "Selected", AppState.SelectedSymbolId == data.Id }
        };

    private async Task OnSymbolMouseDownAsync(SymbolDragEventArgs e)
    {
        currentlyDraggedSymbolOffsetX = e.Draggable.X - WorkspaceModule.GetMouseX(e.ClientX);
        currentlyDraggedSymbolOffsetY = e.Draggable.Y - WorkspaceModule.GetMouseY(e.ClientY);
        currentlyDraggedSymbol = e.Draggable;
        AppState.SelectedSymbolId = e.Draggable.Id;

        await AppState.PersistAsync();
    }

    private async Task OnMouseMoveAsync(MouseEventArgs e)
    {
        await SymbolMoveAsync(e.ClientX, e.ClientY);
    }

    private async Task OnTouchMoveAsync(TouchEventArgs e)
    {
        if (e.Touches.Length == 0)
        {
            return;
        }

        await SymbolMoveAsync(e.Touches[0].ClientX, e.Touches[0].ClientY);
    }

    private async Task SymbolMoveAsync(double clientX, double clientY)
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.X = Math.Max(0, WorkspaceModule.GetMouseX(clientX) + currentlyDraggedSymbolOffsetX);
            currentlyDraggedSymbol.Y = Math.Max(0, WorkspaceModule.GetMouseY(clientY) + currentlyDraggedSymbolOffsetY);

            await UpdateLinePositionsAsync();
        }
    }

    private async Task OnMouseDownAsync()
    {
        AppState.SelectedSymbolId = null;
        AppState.IsOptionsOpen = false;
        await AppState.PersistAsync();
    }

    private async Task OnMouseUpAsync()
    {
        if (currentlyDraggedSymbol is not null)
        {
            currentlyDraggedSymbol.IsDragging = false;
            currentlyDraggedSymbol = null;
            AppState.IsOptionsOpen = true;

            await UpdateLinePositionsAsync();

            await AppState.PersistAsync();
        }
    }

    private async Task OnScrollAsync()
    {
        await UpdateLinePositionsAsync();
    }

    private async Task OnSymbolPointClickAsync(PointClickEventArgs e)
    {
        if (module is null)
        {
            return;
        }

        if (currentConnectorEvent is null)
        {
            if (e.Connector is null)
            {
                // Gets all symbols that are connected to the clicked symbol
                var allConnected = AppState.Symbols.Where(x => x.GetConnectedSymbolIds().Contains(e.Symbol.Id)).ToList();

                if (allConnected.Count == 0)
                {
                    // Action when nothing connects to the point
                    return;
                }

                // removing is "survivable", but it would be better to first loop through the lines, select only one of them, and delete after confirming selection
                foreach (var connectedSymbol in allConnected)
                {
                    var line = lines[(connectedSymbol.Id, e.Symbol.Id)];
                    await line.InvokeVoidAsync("remove");
                    connectedSymbol.RemoveConnection(e.Symbol.Id);
                    lines.Remove((connectedSymbol.Id, e.Symbol.Id));
                }

                return;
            }

            currentConnectorEvent = e;
            await module.InvokeVoidAsync("startLine", e.Element, e.Socket);
            return;
        }

        if (currentConnectorEvent.Symbol.Id == e.Symbol.Id)
        {
            currentConnectorEvent = null;
            await module.InvokeVoidAsync("removeCurrentLine");
            return;
        }

        // if the point is of the kind where arrows are coming from, cannot connect to that one
        if (e.Connector is not null)
        {
            return;
        }

        // if the same symbol connection already exists, do not create a new one
        // makes sense even for Decision, cannot reasonably connect from two branches to the same symbol
        if (lines.ContainsKey((currentConnectorEvent.Symbol.Id, e.Symbol.Id)))
        {
            return;
        }

        var completedLine = await module.InvokeAsync<IJSObjectReference>("endLine", e.Element, e.Socket);

        currentConnectorEvent.Connector?.Invoke(new LineConnection(e.Symbol.Id));

        lines.Add((currentConnectorEvent.Symbol.Id, e.Symbol.Id), completedLine);

        currentConnectorEvent = null;

        await AppState.PersistAsync();
    }

    private async ValueTask UpdateLinePositionsAsync()
    {
        if (module is null)
        {
            return;
        }

        foreach (var line in lines.Values)
        {
            await line.InvokeVoidAsync("position");
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}
