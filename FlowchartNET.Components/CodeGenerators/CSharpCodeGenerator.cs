using FlowchartNET.Components.Symbols.Data;
using System.Text;

namespace FlowchartNET.Components.CodeGenerators;

internal sealed class CSharpCodeGenerator : CodeGenerator
{
    // Track visited symbols to avoid infinite recursion
    private readonly HashSet<Guid> _visited = [];

    // Track symbols that need labels (multiple incoming connections or jump target)
    private readonly HashSet<Guid> _symbolsRequiringLabel = [];

    // Track variables declared
    private readonly HashSet<string> _variables = [];

    protected override void GenerateSymbolCode(StringBuilder sb, StartSymbolData startSymbol, IDictionary<Guid, SymbolData> allSymbols)
    {
        sb.AppendLine("// Generated by Flowchart.NET with goto support");
        // First, detect all symbols that need labels (more than one incoming edge)
        DetectLabels(allSymbols);

        // Generate code starting from the start symbol
        GenerateSymbolCode(sb, 0, startSymbol, allSymbols);
    }

    private void DetectLabels(IDictionary<Guid, SymbolData> allSymbols)
    {
        // Count incoming edges for each symbol
        var incomingCounts = new Dictionary<Guid, int>();

        foreach (var symbol in allSymbols.Values)
        {
            foreach (var connectedId in symbol.GetConnectedSymbolIds())
            {
                incomingCounts[connectedId] = incomingCounts.GetValueOrDefault(connectedId) + 1;
            }
        }

        // Symbols with more than one incoming edge require labels
        foreach (var kvp in incomingCounts)
        {
            if (kvp.Value > 1)
            {
                _symbolsRequiringLabel.Add(kvp.Key);
            }
        }
    }

    private void GenerateSymbolCode(StringBuilder sb, int indent, SymbolData symbol, IDictionary<Guid, SymbolData> allSymbols)
    {
        if (_visited.Contains(symbol.Id))
        {
            // Already generated this block, insert goto
            if (_symbolsRequiringLabel.Contains(symbol.Id))
            {
                sb.Append(new string(' ', indent * 4));
                sb.AppendLine($"goto {FormatLabel(symbol)};");
            }
            return;
        }

        _visited.Add(symbol.Id);

        // If this symbol requires a label (multiple incoming), define label here
        if (_symbolsRequiringLabel.Contains(symbol.Id))
        {
            sb.AppendLine($"{FormatLabel(symbol)}:");
        }

        var indentStr = new string(' ', indent * 4);

        switch (symbol)
        {
            case IOSymbolData ioSymbol:
                sb.Append(indentStr);
                GenerateIoCode(sb, ioSymbol);
                break;

            case ProcessSymbolData processSymbol:
                sb.Append(indentStr);
                if (processSymbol.VariableName is not null)
                {
                    if (_variables.Add(processSymbol.VariableName))
                    {
                        sb.Append("var ");
                    }
                    sb.Append($"{processSymbol.VariableName} = ");
                }
                sb.Append(processSymbol.Process);
                sb.AppendLine(";");
                break;

            case DecisionSymbolData decisionSymbol:
                sb.Append(indentStr);
                sb.AppendLine($"if ({decisionSymbol.Condition})");
                sb.Append(new string(' ', indent * 4));
                sb.AppendLine("{");
                foreach (var trueSymbolId in decisionSymbol.TrueSymbols)
                {
                    if (allSymbols.TryGetValue(trueSymbolId, out var trueSymbol))
                    {
                        GenerateSymbolCode(sb, indent + 1, trueSymbol, allSymbols);
                    }
                }
                sb.Append(new string(' ', indent * 4));
                sb.AppendLine("}");

                if (decisionSymbol.FalseSymbols.Count > 0)
                {
                    sb.Append(new string(' ', indent * 4));
                    sb.AppendLine("else");
                    sb.Append(new string(' ', indent * 4));
                    sb.AppendLine("{");
                    foreach (var falseSymbolId in decisionSymbol.FalseSymbols)
                    {
                        if (allSymbols.TryGetValue(falseSymbolId, out var falseSymbol))
                        {
                            GenerateSymbolCode(sb, indent + 1, falseSymbol, allSymbols);
                        }
                    }
                    sb.Append(new string(' ', indent * 4));
                    sb.AppendLine("}");
                }

                // After if-else, check for common next symbols to continue
                var nextSymbols = GetCommonNextSymbols(decisionSymbol.TrueSymbols, decisionSymbol.FalseSymbols, allSymbols);
                foreach (var nextSymbol in nextSymbols)
                {
                    GenerateSymbolCode(sb, indent, nextSymbol, allSymbols);
                }
                break;

            default:
                break;
        }

        // After processing current symbol, continue with next connected symbols if any
        var connectedIds = symbol.GetConnectedSymbolIds().ToList();

        // Avoid decision symbols' next already handled
        if (symbol is not DecisionSymbolData && connectedIds.Count > 0)
        {
            foreach (var nextId in connectedIds)
            {
                if (allSymbols.TryGetValue(nextId, out var nextSymbol))
                {
                    GenerateSymbolCode(sb, indent, nextSymbol, allSymbols);
                }
            }
        }
    }

    private static IEnumerable<SymbolData> GetCommonNextSymbols(IEnumerable<Guid> trueSymbols, IEnumerable<Guid> falseSymbols, IDictionary<Guid, SymbolData> allSymbols)
    {
        var trueNext = trueSymbols.SelectMany(id => allSymbols[id].GetConnectedSymbolIds()).Distinct();
        var falseNext = falseSymbols.SelectMany(id => allSymbols[id].GetConnectedSymbolIds()).Distinct();

        var commonNextIds = trueNext.Intersect(falseNext);

        return commonNextIds.Select(id => allSymbols[id]);
    }

    private static string FormatLabel(SymbolData symbol)
    {
        var name = symbol.Id.ToString().Replace('-', '_');
        if (char.IsDigit(name[0]))
        {
            name = "_" + name;
        }
        return name;
    }

    private void GenerateIoCode(StringBuilder sb, IOSymbolData symbol)
    {
        if (!string.IsNullOrEmpty(symbol.OutputFormat))
        {
            var outputFormat = string.IsNullOrEmpty(symbol.OutputFormat) ? "{0}" : symbol.OutputFormat;
            sb.AppendLine($"Console.WriteLine(\"{outputFormat}\", {symbol.VariableName});");
            return;
        }

        if (symbol.VariableName is not null)
        {
            if (_variables.Add(symbol.VariableName))
            {
                sb.Append("var ");
            }
            sb.Append($"{symbol.VariableName} = ");
        }

        sb.AppendLine("Console.ReadLine();");
    }
}
