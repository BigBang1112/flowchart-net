using FlowchartNET.Components.Symbols.Data;
using System.Text;

namespace FlowchartNET.Components.CodeGenerators;

internal sealed class CSharpCodeGenerator : CodeGenerator
{
    protected override void GenerateSymbolCode(StringBuilder sb, StartSymbolData startSymbol, IDictionary<Guid, SymbolData> allSymbols)
    {
        sb.AppendLine("// Generated by Flowchart.NET");

        SymbolData symbol = startSymbol;

        while (symbol.GetConnectedSymbolIds().Take(2).Count() == 1)
        {
            var nextSymbol = allSymbols[symbol.GetConnectedSymbolIds().First()];

            switch (nextSymbol)
            {
                case IOSymbolData ioSymbol:
                    GenerateIoCode(sb, ioSymbol, allSymbols);
                    break;
                case ProcessSymbolData processSymbol:
                    if (processSymbol.VariableName is not null)
                    {
                        sb.Append($"var {processSymbol.VariableName} = ");
                    }
                    sb.Append(processSymbol.Process);
                    sb.AppendLine(";");
                    break;
                default:
                    sb.AppendLine($"// Handle other symbol types here");
                    break;
            }

            symbol = nextSymbol;
        }
    }

    private static void GenerateIoCode(StringBuilder sb, IOSymbolData symbol, IDictionary<Guid, SymbolData> allSymbols)
    {
        if (symbol.OutputFormat is null)
        {
            if (symbol.VariableName is not null)
            {
                sb.Append($"var {symbol.VariableName} = ");
            }

            sb.AppendLine($"Console.ReadLine();");
        }
        else
        {
            sb.AppendLine($"Console.WriteLine(\"{string.Format(symbol.OutputFormat, symbol.SimulationValue)}\");");
        }
    }
}
