@implements IAsyncDisposable
@inject ModuleHelper ModuleHelper
@inject AppState AppState
@inject EventBroadcastService EventBroadcast
@inject IJSRuntime JS

<div class="toolbar">
    <ToolbarItem ImageUrl="add_circle.svg" ImageAlt="New" OnClick="ConfirmNewAsync" />
    <ToolbarItem ImageUrl="folder_open.svg" ImageAlt="Open">
        <InputFile class="file" accept=".flowchart" OnChange="LoadFlowchartFile" @ref="inputFileLoad" title=" " />
    </ToolbarItem>
    <ToolbarItem ImageUrl="download.svg" ImageAlt="Save" OnClick="PromptSaveAsync" />
    <ToolbarItem ImageUrl="print.svg" ImageAlt="Print" />
    <ToolbarDivider />
    <ToolbarItem ImageUrl="file_export.svg" ImageAlt="Export">
        <span class="screen-wide">Export as...</span>
    </ToolbarItem>
    <ToolbarDivider />
    <ToolbarItem ImageUrl="frame_source.svg" ImageAlt="Generate code">
        <span class="screen-wide">Generate code</span>
    </ToolbarItem>
    <ToolbarDivider />
    <ToolbarItem ImageUrl="sdk.svg" ImageAlt="Mode">
        <span class="screen-medium">Mode: <b>Logical</b></span>
    </ToolbarItem>
    <ToolbarItem ImageUrl="light_mode.svg" ImageAlt="Light Mode" AdditionalCssClass="align-right" OnClick="ToggleThemeAsync" />
</div>
<ToolbarItem ImageUrl="menu.svg" ImageAlt="Menu" AdditionalCssClass="burger align-right" />

@code {
    private IJSObjectReference? module;
    private InputFile? inputFileLoad;

    private bool toggleTheme;

    private async Task ToggleThemeAsync()
    {
        if (module is null)
        {
            return;
        }

        toggleTheme = !toggleTheme;

        await module.InvokeVoidAsync("toggleTheme", toggleTheme);
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await ModuleHelper.ImportAsync(nameof(Toolbar));
        }
    }

    private async Task ConfirmNewAsync()
    {
        if (await JS.InvokeAsync<bool>("confirm", "Are you sure you want to create a new flowchart?"))
        {
            await NewAsync();
        }
    }

    private async Task NewAsync()
    {
        AppState.Persistent = new PersistentState();

        EventBroadcast.UpdateProperties();
        EventBroadcast.UpdateWorkspace();

        await EventBroadcast.NewFlowchartAsync();

        await AppState.PersistAsync();
    }

    private async Task PromptSaveAsync()
    {
        var fileName = await JS.InvokeAsync<string>("prompt", "Enter the file name to save the flowchart as:", "Untitled.flowchart");

        if (string.IsNullOrWhiteSpace(fileName))
        {
            return;
        }

        if (!fileName.EndsWith(".flowchart", StringComparison.OrdinalIgnoreCase))
        {
            fileName += ".flowchart";
        }

        await using var ms = new MemoryStream();
        await AppState.SaveAsync(ms);

        ms.Position = 0;

        using var streamRef = new DotNetStreamReference(ms);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private async Task LoadFlowchartFile(InputFileChangeEventArgs e)
    {
        var file = e.GetMultipleFiles().FirstOrDefault();

        if (file is null)
        {
            return;
        }

        await using (var stream = file.OpenReadStream(maxAllowedSize: int.MaxValue))
        {
            await AppState.LoadAsync(stream);
        }

        if (module is not null && inputFileLoad?.Element is not null)
        {
            await module.InvokeVoidAsync("resetInputFile", inputFileLoad.Element);
        }

        EventBroadcast.UpdateProperties();
        EventBroadcast.UpdateWorkspace();

        await EventBroadcast.LoadFlowchartAsync();

        await AppState.PersistAsync();
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            try
            {
                await module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}